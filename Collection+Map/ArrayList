一：流程图
  添加（将size+1作为最小容量）=》
  计算容量（将最小容量和默认容量比较-》如果数组是初始空数组则返回默认容量-》否则返回最小容量）=》
  确保确切容量（将最小容量与数组长度作比较-》如果数组长度小于最小容量进行扩容）=》
  扩容（获取旧容量（数组长度）、新容量=》将新容量与最小容量比较，如果小于最小容量，将最小容量赋值为新容量）

一：
动态数组
初始化容量为0，第一次添加数据时才会扩容
扩容每次容量是原来的1.5倍，每次扩容都需要拷贝数组
添加数据：确保已知数组已使用长度（size）+1足够存下新元素。计算容量，如果数组已经使用长度+1大于当前数组长度，
调用grow方法进行扩容（原来的1.5倍）。确保新增的数据有位置存储以后，将新增的元素添加到size的位置上。
返回添加成功布尔值
底层（ArrayList底层是用动态数组实现的）-原来的容量（ArrayList初始容量为0，第一次添加数据时才初始化容量为10）-扩容（每次扩容为原来容量的1.5倍，每次扩容都要拷贝数组）-添加数据
（确保当前数组已使用长度+1足够存下下一个数据）足够存=》（确定容量，数组已使用长度+1大于当前数组长度）数组已使用长度=》扩容（调用grow方法进行扩容，原来的1.5倍）=》返回添加成功布尔值
